/*
 * This script exposes a "/status" endpoint that returns Prometheus metrics that can be scraped.
 * It will be reachable under "<ip>/script/<id>/metrics". Id will be 1 if this is your first script.
 *
 * Example Prometheus config:
 *
 * scrape_configs:
 *   - job_name: 'shelly'
 *     metrics_path: /script/1/metrics
 *     static_configs:
 *       - targets: ['<ip>']
 *
 * Replace <ip> with the ip address of the device and adjust the script id if needed.
 *
 * If you use Grafana to display metrics scraped, you can give a try to the example dashboard in prometheus-grafana-example-dashboard.json
 * available via the url https://raw.githubusercontent.com/ALLTERCO/shelly-script-examples/main/prometheus-grafana-example-dashboard.json
 *
 * Note: This script assumes you have one switch, but you can configure that in the Configuration section
 */
// ---------------------------------------------------------------------------------------------------------------------
// Configuration (you can change / adapt here)
// ---------------------------------------------------------------------------------------------------------------------

// Prefix added to all metrics name
const metric_prefix = "shelly_"
// url of metrics. will be used for the last part of "<ip>/script/<id>/<url>"
//    where ip = your plug ip/hostname; id the script id or number (1 if this is the first); url the value below
const url = "metrics"

// List of internal switch to monitor using the shelly's id naming scheme in the form of switch:<id> (ex switch:0)
const monitored_components = []
const monitored_temperature = ["temperature:100"]
// ---------------------------------------------------------------------------------------------------------------------
// Prometheus exporter
// ---------------------------------------------------------------------------------------------------------------------

const TYPE_GAUGE = "gauge"
const TYPE_COUNTER = "counter"

var info = Shelly.getDeviceInfo();

function promLabel(label, value) {
  return [label, "=", '"', value, '"'].join("");
}

// Will be added to every metrics
var defaultLabels = [
  ["name", info.name],
  ["id", info.id],
  ["mac", info.mac],
  ["app", info.app]
]
  .map(function (data) {
    return promLabel(data[0], data[1]);
  });

/**
 *  Generate one metric output with all the shenanigans around it
 * @param name The name of the metrics (Will be prefixed by metric_prefix value)
 * @param type One of the TYPE_* of metrics. Usually Counter, Gauge, Histogram (not supported yes)
 * @param specificLabels Array of labels generated by promLabel() specific to this metric.
 * @param description An Human description of the metric
 * @param value The actual metric numeric value
 * @returns {string} The metric string to include in final response
 */
function printPrometheusMetric(name, type, specificLabels, description, value) {
  return [
    "# HELP ", metric_prefix, name, " ", description, "\n",
    "# HELP ", metric_prefix, name, " ", type, "\n",
    metric_prefix, name, "{", defaultLabels.join(","), specificLabels.length > 0 ? "," : "", specificLabels.join(","), "}", " ", value, "\n\n"
  ].join("");
}

/**
 * HTTP handler that will be called when the url will be accessed
 * @param request
 * @param response
 */
function httpServerHandler(request, response) {
  response.body = [
    generateMetricsForSystem(),
    monitored_components.map(function (string_id) {
      return generateMetricsForComponent(string_id)
    }).join(""),
    monitored_temperature.map(function (string_id) {
      return generateMetricsForTemperature(string_id)
    }).join(""),
  ].join("")
  response.headers = [["Content-type", "text/plain"]];
  response.code = 200;
  response.send();
}

/**
 * Generate metrics for the system part
 * @returns {string}
 */
function generateMetricsForSystem() {
  const sys = Shelly.getComponentStatus("sys")
  return [
    printPrometheusMetric("uptime_seconds", TYPE_COUNTER, [], "power level in watts", sys.uptime),
    printPrometheusMetric("ram_size_bytes", TYPE_GAUGE, [], "Internal board RAM size in bytes", sys.ram_size),
    printPrometheusMetric("ram_free_bytes", TYPE_GAUGE, [], "Internal board free RAM size in bytes", sys.ram_free)
  ].join("")
}

/**
 * generate metrics for one dynamic component with the name given as parameter
 * @returns {string}
 */
function generateMetricsForComponent(string_id) {
  const component = Shelly.getComponentStatus(string_id);
  const component_type = string_id.substr(0, string_id.indexOf(":"));
  const id = string_id.substr(string_id.indexOf(":") + 1);
  return [
    printPrometheusMetric(component_type + "_value", TYPE_GAUGE, 
                          [promLabel(component_type, id)], component_type + " value", component.value),
  ].join("");
}

/**
 * generate metrics for one temperature component with the name given as parameter
 * @returns {string}
 */
function generateMetricsForTemperature(string_id) {
  const component = Shelly.getComponentStatus(string_id);
  const component_type = string_id.substr(0, string_id.indexOf(":"));
  const id = string_id.substr(string_id.indexOf(":") + 1);
  return [
    printPrometheusMetric("temperature_C", TYPE_GAUGE, 
                          [promLabel(component_type, id)], "Temperature value", component.tC),
  ].join("");
}

HTTPServer.registerEndpoint(url, httpServerHandler);